name: Build Android APK

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:  # Permite ejecutar manualmente

jobs:
  build:
    runs-on: ubuntu-20.04
    
    steps:
    - name: Checkout código
      uses: actions/checkout@v3
    
    - name: Configurar Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Instalar dependencias del sistema
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          git zip unzip openjdk-17-jdk wget \
          autoconf libtool pkg-config zlib1g-dev \
          libncurses5-dev libncursesw5-dev libtinfo5 \
          cmake libffi-dev libssl-dev
    
    - name: Instalar Buildozer y Cython
      run: |
        pip install --upgrade pip
        pip install buildozer==1.5.0 cython==0.29.36
    
    - name: Crear buildozer.spec simplificado (SIN MediaPipe)
      run: |
        cat > buildozer.spec << 'EOF'
        [app]
        title = SeñasCol
        package.name = senascol
        package.domain = org.senascol
        
        source.dir = .
        source.include_exts = py,png,jpg,kv,json,tflite
        
        version = 1.0
        
        # SIN MediaPipe - Solo lo esencial
        requirements = python3==3.9.5,kivy==2.1.0,opencv,numpy,pillow,requests,pyjnius,android
        
        android.permissions = CAMERA,INTERNET,WRITE_EXTERNAL_STORAGE,READ_EXTERNAL_STORAGE
        
        android.gradle_dependencies = org.tensorflow:tensorflow-lite:2.9.0,org.tensorflow:tensorflow-lite-select-tf-ops:2.9.0
        
        orientation = portrait
        fullscreen = 0
        
        android.api = 31
        android.minapi = 21
        android.ndk = 23b
        android.accept_sdk_license = True
        
        android.archs = arm64-v8a
        
        p4a.bootstrap = sdl2
        p4a.branch = master
        
        [buildozer]
        log_level = 2
        warn_on_root = 1
        EOF
    
    - name: Usar traductor sin MediaPipe
      run: |
        # Renombrar traductor original
        mv traductor.py traductor_mediapipe.py.bak
        
        # Crear traductor simplificado
        cat > traductor.py << 'PYEOF'
        """Traductor simplificado sin MediaPipe"""
        import cv2
        import numpy as np
        import json
        import os
        import time
        
        try:
            import tensorflow as tf
            TENSORFLOW_AVAILABLE = True
        except:
            TENSORFLOW_AVAILABLE = False
        
        class SignLanguageTranslator:
            def __init__(self):
                print("🔄 Inicializando traductor simple...")
                self.STATIC_FRAMES_REQUIRED = 15
                self.PREDICTION_COOLDOWN = 30
                self.CONFIDENCE_STATIC = 0.65
                self.sentence = []
                self.static_counter = 0
                self.cooldown_counter = 0
                self.last_prediction_time = 0
                self.prediction_cooldown = 1.5
                self.interpreter_static = None
                self.input_details_static = None
                self.output_details_static = None
                self.stats = {'static_predictions': 0, 'dynamic_predictions': 0, 'errors': 0}
                self.load_models()
                self.load_words()
                print("✅ Traductor simple listo")
            
            def load_models(self):
                if not TENSORFLOW_AVAILABLE:
                    return
                base_path = os.path.dirname(os.path.abspath(__file__))
                static_path = os.path.join(base_path, "models", "static_letters_model.tflite")
                if os.path.exists(static_path):
                    try:
                        self.interpreter_static = tf.lite.Interpreter(model_path=static_path)
                        self.interpreter_static.allocate_tensors()
                        self.input_details_static = self.interpreter_static.get_input_details()
                        self.output_details_static = self.interpreter_static.get_output_details()
                        print("✅ Modelo TFLite cargado")
                    except Exception as e:
                        print(f"❌ Error: {e}")
            
            def load_words(self):
                base_path = os.path.dirname(os.path.abspath(__file__))
                words_json = os.path.join(base_path, "words.json")
                if os.path.exists(words_json):
                    with open(words_json, "r", encoding="utf-8") as f:
                        data = json.load(f)
                        self.word_static = data.get("word_static", [])
                else:
                    self.word_static = ["A", "B", "C", "D", "E", "F", "I", "L", "M", "N", "O", "P", "Q", "R", "T", "U", "V", "W", "X", "Y", "K"]
                print(f"✅ {len(self.word_static)} letras")
            
            def detect_hand_region(self, frame):
                hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
                lower = np.array([0, 20, 70], dtype=np.uint8)
                upper = np.array([20, 255, 255], dtype=np.uint8)
                mask = cv2.inRange(hsv, lower, upper)
                contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                if contours:
                    max_c = max(contours, key=cv2.contourArea)
                    if cv2.contourArea(max_c) > 5000:
                        x, y, w, h = cv2.boundingRect(max_c)
                        x = max(0, x - 20)
                        y = max(0, y - 20)
                        w = min(frame.shape[1] - x, w + 40)
                        h = min(frame.shape[0] - y, h + 40)
                        return frame[y:y+h, x:x+w], True
                return None, False
            
            def extract_features(self, roi):
                try:
                    resized = cv2.resize(roi, (64, 64))
                    gray = cv2.cvtColor(resized, cv2.COLOR_BGR2GRAY)
                    normalized = gray.astype(np.float32) / 255.0
                    features = normalized.flatten()
                    if len(features) > 63:
                        indices = np.linspace(0, len(features)-1, 63).astype(int)
                        features = features[indices]
                    elif len(features) < 63:
                        features = np.pad(features, (0, 63 - len(features)), 'constant')
                    return features.astype(np.float32)
                except:
                    return np.zeros(63, dtype=np.float32)
            
            def process_frame(self, frame):
                try:
                    current_time = time.time()
                    if self.cooldown_counter > 0:
                        self.cooldown_counter -= 1
                    roi, detected = self.detect_hand_region(frame)
                    if not detected:
                        self.static_counter = 0
                        return {"status": "waiting", "message": "Muestra la mano"}
                    self.static_counter += 1
                    if (self.static_counter >= self.STATIC_FRAMES_REQUIRED and 
                        self.cooldown_counter == 0 and
                        current_time - self.last_prediction_time > self.prediction_cooldown):
                        pred = self.predict_static(roi)
                        if pred:
                            self.sentence.append(pred)
                            self.cooldown_counter = self.PREDICTION_COOLDOWN
                            self.last_prediction_time = current_time
                            self.static_counter = 0
                            return {"prediction": pred, "type": "static", "status": "success"}
                    if self.static_counter > 0:
                        progress = min(100, (self.static_counter / self.STATIC_FRAMES_REQUIRED) * 100)
                        return {"status": "accumulating", "counter": f"{self.static_counter}/{self.STATIC_FRAMES_REQUIRED}", "progress": progress}
                    return {"status": "detecting"}
                except Exception as e:
                    return {"status": "error"}
            
            def predict_static(self, roi):
                if self.interpreter_static is None:
                    return None
                try:
                    features = self.extract_features(roi)
                    if np.sum(np.abs(features)) < 0.05:
                        return None
                    max_val = np.max(np.abs(features))
                    if max_val > 0:
                        normalized = features / max_val
                    else:
                        normalized = features
                    input_data = np.expand_dims(normalized, axis=0).astype(np.float32)
                    self.interpreter_static.set_tensor(self.input_details_static[0]['index'], input_data)
                    self.interpreter_static.invoke()
                    predictions = self.interpreter_static.get_tensor(self.output_details_static[0]['index'])[0]
                    pred_idx = np.argmax(predictions)
                    confidence = float(predictions[pred_idx])
                    if confidence >= self.CONFIDENCE_STATIC and pred_idx < len(self.word_static):
                        return self.word_static[pred_idx]
                    return None
                except:
                    return None
            
            def reset(self):
                self.sentence = []
                self.static_counter = 0
                self.cooldown_counter = 0
            
            def get_sentence(self):
                return ' '.join(self.sentence)
            
            def get_stats(self):
                return self.stats
        PYEOF
    
    - name: Compilar APK
      run: |
        yes | buildozer android debug || true
    
    - name: Subir APK
      uses: actions/upload-artifact@v3
      with:
        name: senascol-apk
        path: bin/*.apk
        if-no-files-found: warn